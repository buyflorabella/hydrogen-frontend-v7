# Platform Template Reference Guide — v2

**Created:** 2026-02-10
**Updated:** 2026-02-10
**Purpose:** Importable guidance for any program that creates new websites based on the platform-template
**Source:** `/opt/operations/platform-template/`
**Supersedes:** `platform_template_reference.md` (v1)

---

## Changelog from v1

| Section | What Changed |
|---------|-------------|
| 3 — Directory Structure | Backend expanded: `api/`, `routes/`, `static/`, populated `templates/` |
| 4.1 — Backend | Rewrote entirely: app factory, flask-restx API layer, Jinja2 page routes |
| 5 — Design Patterns | Added: Three Route Layers, Blueprint-based API, app factory pattern |
| 8 — Technology Stack | Added: flask-restx |
| 9 — What NOT to Change | Added: api/ Blueprint pattern, error isolation, factory pattern |
| 10 — What to Customize | Updated: add namespaces (not inline routes), add pages to routes/ |

---

## 1. What This Document Is

This is a complete structural and behavioral specification of the **platform-template** — a reusable Flask + React scaffolding located at `/opt/operations/platform-template/`. Any program creating a new website MUST clone this template and follow its conventions exactly. This document describes every file, every convention, and every pattern so that new sites are structurally identical to the template.

---

## 2. When to Use the Platform Template

Use platform-template as the starting point for **every** new website. The workflow is:

1. Clone `platform-template/` into a new repository named after the site
2. Configure the site in `site-management/group_vars/all/ports.yml` (port allocation)
3. Run Ansible from `site-management/` to generate environment-specific settings files
4. Develop the site by adding routes, components, and business logic to the cloned scaffold

**Never build a site from scratch.** Always start from the template.

---

## 3. Complete Directory Structure

```
platform-template/
├── backend/                          # Flask application
│   ├── app.py                        # App factory + module-level `app = create_app()`
│   ├── config.py                     # Configuration class (env vars + flask-restx settings)
│   ├── requirements.txt              # Python dependencies (flask, flask_cors, flask-restx, gunicorn, eventlet)
│   ├── api/                          # flask-restx REST API layer
│   │   ├── __init__.py               # Blueprint("api") + Api(doc="/docs") + namespace registration
│   │   └── health.py                 # Health namespace — example endpoint with Swagger model
│   ├── routes/                       # Jinja2 server-rendered page routes
│   │   ├── __init__.py               # Exports pages_bp
│   │   └── pages.py                  # GET / renders index.html
│   ├── templates/                    # Jinja2 HTML templates
│   │   ├── base.html                 # Base layout with nav (Home + API Docs)
│   │   └── index.html                # Landing page: fetches /api/health, shows result
│   └── static/                       # Static assets served by pages_bp
│       └── css/
│           └── app.css               # Minimal base styles (sites override)
│
├── frontend/                         # React + Vite application
│   ├── index.html                    # HTML entry point with <div id="root">
│   ├── package.json                  # NPM dependencies and build scripts
│   ├── vite.config.js                # Vite build configuration with React plugin
│   ├── .env.example                  # Template showing required VITE_* variables
│   ├── .gitignore                    # Ignores node_modules/, dist/, .env
│   └── src/
│       ├── main.jsx                  # React root renderer (mounts <App /> to #root)
│       ├── App.jsx                   # Main component with backend health-check demo
│       └── components/               # Reserved for React components (empty by default)
│
├── script/                           # Configuration and launcher scripts
│   ├── settings.txt                  # Shared non-secret defaults (all environments)
│   ├── settings.sh                   # Auto-detector: sources correct env file based on PWD
│   ├── settings.dev.sh               # Dev environment overrides   (GENERATED BY ANSIBLE)
│   ├── settings.staging.sh           # Staging environment overrides (GENERATED BY ANSIBLE)
│   ├── settings.prod.sh              # Prod environment overrides  (GENERATED BY ANSIBLE)
│   ├── manage.sh                     # Main entry point: --frontend / --backend / --gunicorn
│   ├── run-backend.sh                # Sources settings, exports env vars, runs Flask
│   ├── run-frontend.sh               # Sources settings, generates .env, runs Vite dev server
│   ├── run-gunicorn.sh               # Sources settings, runs Gunicorn with eventlet workers
│   └── generate-env.sh               # Generates frontend/.env and root .env from settings
│
├── systemd/                          # Example systemd configuration (templates)
│   ├── site.service.example          # Systemd unit file template for Gunicorn
│   └── site.env.example              # Environment file template for systemd
│
├── .gitignore                        # Project-level git ignores
└── README.md                         # Quick-start documentation
```

**Total: 27 tracked files across 4 top-level directories** (was 21 in v1).

---

## 4. File-by-File Specification

### 4.1 Backend — `/backend/`

#### Route Architecture (three layers)

```
Request arrives
    │
    ├── GET /             → pages_bp     → routes/pages.py  → renders index.html (Jinja2)
    ├── GET /static/*     → pages_bp     → serves static/css/app.css
    │
    ├── GET /api/health   → api_bp       → flask-restx      → health_ns → HealthCheck.get()
    ├── GET /api/docs     → api_bp       → flask-restx      → Swagger UI (built-in)
    └── GET /api/*        → api_bp       → flask-restx      → (future namespaces)
```

**Error isolation:** A 404 on `/api/nope` returns JSON. A 404 on `/nope` returns HTML. This is achieved by attaching the `Api` to a Blueprint, not the Flask app directly.

#### `app.py` — App Factory + Module-Level App

```python
def create_app():
    app = Flask(__name__)
    app.config.from_object("config.Config")
    CORS(app, resources={r"/api/*": {"origins": ...}})
    app.register_blueprint(api_bp)    # /api/*
    app.register_blueprint(pages_bp)  # /
    return app

app = create_app()  # module-level for gunicorn
```

- **`create_app()` factory** enables test isolation (fresh app per test)
- **`app = create_app()`** at module level satisfies `gunicorn app:app`
- **`if __name__ == "__main__"`** block satisfies `python3 app.py`
- CORS is restricted to `/api/*` routes only, using domains from `ALLOWED_CORS_DOMAINS`

#### `config.py` — Configuration Class

Single `Config` class with attributes read from `os.environ.get()`:

| Attribute | Default | Source |
|-----------|---------|--------|
| `SECRET_KEY` | `"change-me-in-production"` | `FLASK_SECRET_KEY` env var |
| `ALLOWED_CORS_DOMAINS` | `""` (none) | `ALLOWED_CORS_DOMAINS` env var |
| `BACKEND_HOST` | `"127.0.0.1"` | `BACKEND_HOST` env var |
| `BACKEND_PORT` | `5001` | `BACKEND_PORT` env var |
| `RESTX_MASK_SWAGGER` | `False` | Hardcoded — removes X-Fields header from Swagger UI |
| `SWAGGER_UI_DOC_EXPANSION` | `"list"` | Hardcoded — endpoints shown expanded by default |
| `APP_NAME` | `"Platform Template"` | `APP_NAME` env var |
| `APP_VERSION` | `"1.0.0"` | `APP_VERSION` env var |

**Convention**: Never hardcode secrets. Always read from environment.

#### `requirements.txt` — Python Dependencies

```
flask
flask_cors
flask-restx
gunicorn
eventlet
```

- These five are the minimum. Add project-specific deps below them.
- **Do not remove** any of the five base dependencies.

#### `api/__init__.py` — API Blueprint + flask-restx Api

- Creates `api_bp = Blueprint("api", __name__, url_prefix="/api")`
- Attaches `Api(api_bp, doc="/docs")` — Swagger UI served at `/api/docs`
- Registers namespaces (currently: `health_ns`)
- Provides `app_errorhandler(404)` that returns JSON for `/api/*` paths, HTML for everything else

**Key design decision:** `Api` is on a Blueprint, not the Flask app. This means flask-restx's JSON error handlers only fire for `/api/*` routes. Without this, all 404s (including page requests) would return JSON.

#### `api/health.py` — Health Namespace

- `health_ns = Namespace("health", description="Health check operations")`
- Defines `health_model` with `status` + `env` fields (auto-generates Swagger docs)
- Class-based `HealthCheck(Resource)` with `@marshal_with(health_model)`
- `GET /api/health` returns `{"status": "ok", "env": "<ENV>"}`

#### `routes/__init__.py` — Page Blueprint Export

Single-line module: exports `pages_bp` from `pages.py`.

#### `routes/pages.py` — Jinja2 Page Routes

- `pages_bp = Blueprint("pages", ..., template_folder="../templates", static_folder="../static")`
- `GET /` renders `index.html`
- **New sites**: Add page routes here (e.g., `/about`, `/dashboard`)

#### `templates/base.html` — Base Layout

- Nav bar with "Home" link and "API Docs" link (opens `/api/docs` in new tab)
- Three Jinja2 blocks: `{% block title %}`, `{% block content %}`, `{% block scripts %}`
- Links the base stylesheet from `static/css/app.css`

#### `templates/index.html` — Landing Page

- Extends `base.html`
- "API Health Check" section: vanilla JS `fetch("/api/health")`, displays JSON in `<pre>`
- "Quick Links" section: links to Swagger UI and raw health endpoint
- **New sites**: Replace with site-specific landing page content

#### `static/css/app.css` — Base Styles

- System font stack, dark nav bar, container, card, `<pre>` code block styling
- Not opinionated — sites will override with their own styles
- Served by the `pages_bp` Blueprint's `static_folder`

---

### 4.2 Frontend — `/frontend/`

*(Unchanged from v1)*

#### `package.json` — NPM Configuration
- **Runtime deps**: `react@^19`, `react-dom@^19`, `react-router-dom@^7`
- **Dev deps**: `@vitejs/plugin-react@^5`, `vite@^7`
- Module type: `"type": "module"`
- Scripts: `dev` (Vite dev server), `build` (production build), `lint`, `preview`

#### `vite.config.js` — Vite Build Config
- Uses `@vitejs/plugin-react`
- Dev server port read from `process.env.VITE_FRONTEND_PORT`
- `allowedHosts` can be configured for external access (commented example provided)

#### `index.html` — HTML Entry Point
- Contains `<div id="root"></div>` mount point
- Loads `/src/main.jsx` as ES module
- **Keep minimal.** All rendering happens in React.

#### `.env.example` — Environment Variable Template
```
VITE_API_BASE_URL=http://localhost:15101
VITE_FRONTEND_PORT=15100
VITE_BACKEND_PORT=15101
VITE_ENV=development
```
- Shows required variables. Actual `.env` is generated by `generate-env.sh`.
- **All frontend env vars MUST use `VITE_` prefix** (Vite requirement for build-time exposure).

#### `src/main.jsx` — React Root Renderer
- Renders `<App />` into `#root` element
- Uses `createRoot` from React 19

#### `src/App.jsx` — Main Application Component
- Demonstrates backend connectivity via health-check fetch
- Uses `import.meta.env.VITE_API_BASE_URL` for API URL
- **New sites**: Replace the health-check demo with actual application UI.

#### `src/components/` — Component Directory
- Empty by default. Organize React components here.
- **Convention**: PascalCase filenames (e.g., `UserProfile.jsx`, `NavBar.jsx`)

---

### 4.3 Scripts — `/script/`

*(Unchanged from v1)*

This is the configuration and orchestration layer. **Scripts are the glue between Ansible-generated config and the running application.**

#### Configuration Flow (critical to understand)

```
settings.txt          Shared defaults (checked into git)
     │
     v
settings.sh           Auto-detector (checked into git)
     │  inspects $PWD to determine environment
     │  sources settings.txt FIRST
     │  then sources the correct environment file:
     ├──> settings.dev.sh        (GENERATED by Ansible, git-ignored)
     ├──> settings.staging.sh    (GENERATED by Ansible, git-ignored)
     └──> settings.prod.sh       (GENERATED by Ansible, git-ignored)
              │
              v
         manage.sh               Dispatcher (checked into git)
              │  receives --frontend, --backend, or --gunicorn
              ├──> run-frontend.sh  ──> generate-env.sh ──> npm run dev
              ├──> run-backend.sh   ──> generate-env.sh ──> python3 app.py
              └──> run-gunicorn.sh  ──> gunicorn -k eventlet ...
```

#### `settings.txt` — Shared Defaults
Non-secret configuration shared across all environments:
```bash
FRONTEND_DIR="frontend"
FRONTEND_HOST=localhost
PYTHON_BIN="python3"
WORKERS=3
BACKEND_DIR="backend"
BACKEND_APP_SCRIPT=app
BACKEND_HOST="127.0.0.1"
ALLOWED_CORS_DOMAINS=""
```
- **Never put secrets here.** This file is checked into git.
- New sites may add shared (non-secret) config variables here.

#### `settings.sh` — Environment Auto-Detector
- **Must be sourced, not executed**: `source script/settings.sh`
- Inspects `$PWD` for directory patterns: `/dev/`, `/staging/`, `/prod/`
- Sources `settings.txt` first, then the matching `settings.<env>.sh`
- Exports all variables so subshells inherit them
- Fails with clear error if environment cannot be detected

#### `settings.dev.sh` / `settings.staging.sh` / `settings.prod.sh`
- **GENERATED BY ANSIBLE** — do not edit manually
- **Git-ignored** — not committed to the repository
- Contain environment-specific overrides:
  ```bash
  ENV=development
  FRONTEND_PORT=15100
  BACKEND_PORT=15101
  NODE_ENV=development
  DEBUG=true
  ```

#### Port Allocation by Environment

| Environment | Frontend Port | Backend Port | Debug |
|-------------|--------------|--------------|-------|
| dev         | 15100        | 15101        | true  |
| staging     | 17100        | 17101        | false |
| prod        | 20100        | 20101        | false |

- Ports are assigned in `site-management/group_vars/all/ports.yml`
- Each site gets a 10-port block. Site N offset = N * 10
- **Never hardcode ports.** Always read from settings files.

#### `manage.sh` — Main Entry Point
Usage:
```bash
./script/manage.sh --frontend    # Start Vite dev server
./script/manage.sh --backend     # Start Flask dev server
./script/manage.sh --gunicorn    # Start Gunicorn (production)
```
- Dispatches to the appropriate `run-*.sh` script
- Each run script sources `settings.sh` internally

#### `generate-env.sh` — .env File Generator
- Sources `settings.sh` to auto-detect environment
- Generates `frontend/.env` with `VITE_*` prefixed variables
- Generates root `.env` with backend variables
- Uses `set -euo pipefail` (strict error handling)
- **Both generated files have "do not edit" headers**

#### `run-backend.sh` — Flask Launcher
- Calls `generate-env.sh` to ensure .env files exist
- Exports `FLASK_SECRET_KEY`, `BACKEND_HOST`, `BACKEND_PORT`, `DEBUG`, etc.
- Runs: `python3 backend/app.py`

#### `run-frontend.sh` — Vite Launcher
- Calls `generate-env.sh` to ensure .env files exist
- Changes to `frontend/` directory
- Runs: `npm run dev`

#### `run-gunicorn.sh` — Production Launcher
- Calls `generate-env.sh` to ensure .env files exist
- Exports backend environment variables
- Runs: `gunicorn -k eventlet -w $WORKERS -b $BACKEND_HOST:$BACKEND_PORT app:app`
- Working directory: `backend/`

---

### 4.4 Systemd — `/systemd/`

*(Unchanged from v1)*

#### `site.service.example`
```ini
[Unit]
Description=Gunicorn for <site-name>
After=network.target

[Service]
User=apache
Group=apache
WorkingDirectory=/var/www/html/<site-name>/backend
EnvironmentFile=/etc/systemd/system/<site-name>.env
ExecStart=/usr/local/bin/gunicorn -k eventlet -w 3 -b 127.0.0.1:<backend-port> app:app

[Install]
WantedBy=multi-user.target
```

#### `site.env.example`
```bash
ENV=production
BACKEND_PORT=20101
FRONTEND_PORT=20100
BACKEND_HOST=127.0.0.1
```

- These are reference examples only.
- **Actual systemd files are generated by Ansible** during deployment.
- Always runs as `apache:apache` user.
- Backend binds to `127.0.0.1` (localhost only — Apache reverse-proxies public traffic).

---

### 4.5 Git Configuration

*(Unchanged from v1)*

#### `.gitignore` (project root)
```
script/settings.*.sh        # Ansible-generated environment settings
.env                         # Generated root environment file
frontend/.env                # Generated frontend environment file
frontend/node_modules/       # NPM packages
frontend/dist/               # Built frontend assets
backend/__pycache__/         # Python bytecode cache
backend/*.pyc                # Python compiled files
.idea/                       # JetBrains IDE
.vscode/                     # VS Code
*.swp                        # Vim swap files
*.swo                        # Vim swap files
```

#### Branch Strategy
- `main` — production branch
- `staging` — staging environment
- `dev` — development branch
- Promotion flow: `dev` -> `staging` -> `main`
- Git worktrees supported for simultaneous branch access

---

## 5. Design Patterns and Conventions

### 5.1 Three Route Layers (NEW in v2)

Every site serves three types of HTTP traffic from a single Flask process:

| Layer | URL Prefix | Technology | Purpose |
|-------|-----------|------------|---------|
| REST API | `/api/*` | flask-restx `Resource` classes | JSON endpoints for frontend consumption |
| Swagger UI | `/api/docs` | flask-restx built-in | Interactive API documentation + testing |
| Jinja2 Pages | `/` | Jinja2 templates | Server-rendered HTML (mirrors React frontend) |

**Why all three exist:**
- **REST API** — the data contract between frontend and backend. Auto-documented via model definitions.
- **Swagger UI** — free from flask-restx. Developers validate endpoints without frontend code. "Try it out" sends real requests.
- **Jinja2 Pages** — working HTML that demonstrates the same flows the React app will implement. Useful for prototyping, SSR fallback, and admin pages.

### 5.2 Blueprint-Based API Isolation (NEW in v2)

The `Api` object lives on a Blueprint, **never** on the Flask app directly:

```python
api_bp = Blueprint("api", __name__, url_prefix="/api")
api = Api(api_bp, doc="/docs")
```

**Why:** flask-restx installs its own error handlers. If `Api` is on the app, *all* 404s return JSON — even requests for HTML pages. Isolating `Api` on a blueprint gives:
- `GET /nope` → Flask's default HTML 404
- `GET /api/nope` → JSON `{"message": "Not found", "status": 404}`

**This pattern is mandatory.** Do not attach `Api` to the Flask app.

### 5.3 App Factory Pattern (NEW in v2)

```python
def create_app():
    app = Flask(__name__)
    app.config.from_object("config.Config")
    CORS(app, ...)
    app.register_blueprint(api_bp)
    app.register_blueprint(pages_bp)
    return app

app = create_app()
```

The factory satisfies three consumers simultaneously:
- `python3 app.py` — `__main__` block calls `app.run()`
- `gunicorn app:app` — imports module-level `app` variable
- Tests — call `create_app()` with test config

### 5.4 Environment Detection from Directory Path

The core pattern: **the working directory determines the environment.** When using git worktrees, each branch lives in its own directory (`/path/to/site/dev/`, `/path/to/site/staging/`, `/path/to/site/prod/`). The `settings.sh` script inspects `$PWD` for these path segments and sources the correct settings file. This eliminates manual environment switching.

### 5.5 Ansible as Single Source of Truth for Infrastructure
- **Ansible generates** the `settings.*.sh` files — the app never defines its own ports
- **Ansible manages** vhosts, SSL certificates, and systemd services
- **The app only reads** environment variables — it never knows about infrastructure directly
- This separation means you can re-port or re-deploy a site by changing one Ansible variable

### 5.6 Layered Configuration (Shared + Override)
Configuration follows a strict hierarchy:
1. `settings.txt` — shared non-secret defaults (version-controlled)
2. `settings.<env>.sh` — environment-specific overrides (Ansible-generated, git-ignored)
3. `.env` files — generated from the above for tools that need dotenv format (Vite)

### 5.7 No Secrets in Version Control
- `settings.txt` contains **only** non-secret defaults
- Secrets live in Ansible Vault (`site-management/group_vars/all/vault.yml`)
- Ansible injects secrets into `settings.*.sh` at deploy time
- `.env` files are git-ignored

### 5.8 Backend Binds to Localhost Only
- Flask/Gunicorn always binds to `127.0.0.1`
- Apache reverse-proxies public traffic to the local port
- This is a security boundary — the app is never directly exposed to the internet

### 5.9 CORS Driven by Configuration
- Allowed CORS domains come from `ALLOWED_CORS_DOMAINS` environment variable
- Parsed as comma-separated list in `app.py`
- Empty by default (no cross-origin access unless configured)

### 5.10 Health Check as Connectivity Proof
- Every site MUST have `GET /api/health` returning `{"status": "ok", "env": "<ENV>"}`
- Both the Jinja2 landing page and the React `App.jsx` demonstrate fetching this endpoint
- This endpoint is used for smoke testing and monitoring

---

## 6. How to Create a New Site from This Template

### Step 1 — Clone the Template
```bash
cp -r /opt/operations/platform-template /opt/operations/<new-site-name>
cd /opt/operations/<new-site-name>
rm -rf .git
git init
git checkout -b main
git add .
git commit -m "feat: scaffold <new-site-name> from platform-template"
git checkout -b staging
git checkout -b dev
```

### Step 2 — Register the Site in Ansible
Add an entry to `/opt/operations/site-management/group_vars/all/ports.yml`:
```yaml
website_sites:
  <new-site-name>:
    domain: <subdomain>.<domain>.com
    site_index: <next_available_index>
    admin_email: admin@example.com
    webroot: /var/www/html/<new-site-name>
    has_frontend: true
    ports:
      dev:
        frontend: <15100 + (site_index * 10)>
        backend: <15101 + (site_index * 10)>
      staging:
        frontend: <17100 + (site_index * 10)>
        backend: <17101 + (site_index * 10)>
      prod:
        frontend: <20100 + (site_index * 10)>
        backend: <20101 + (site_index * 10)>
    vhost_prefix:
      prod: "010"
      staging: "050"
      dev: "090"
```

### Step 3 — Run Ansible to Generate Config
```bash
cd /opt/operations/site-management
ansible-playbook playbooks/deploy_site.yml -e target_group=<server_group>
```
This generates:
- `script/settings.dev.sh`, `settings.staging.sh`, `settings.prod.sh` in the site repo
- Apache vhost configs in `/etc/httpd/conf.d/`
- SSL certificates via certbot
- Systemd service file for production

### Step 4 — Develop
```bash
cd /opt/operations/<new-site-name>
git checkout dev
./script/manage.sh --backend     # Terminal 1
./script/manage.sh --frontend    # Terminal 2
```

### Step 5 — Customize
- Add API namespaces in `backend/api/` (see section 6.1)
- Add page routes in `backend/routes/pages.py` (see section 6.2)
- Add React components in `frontend/src/components/`
- Add Python dependencies to `backend/requirements.txt`
- Add NPM dependencies to `frontend/package.json`
- Add shared non-secret config to `script/settings.txt`

### 6.1 How to Add a New API Namespace

1. Create `backend/api/items.py`:
```python
from flask_restx import Namespace, Resource, fields

items_ns = Namespace("items", description="Item operations")

item_model = items_ns.model("Item", {
    "id": fields.Integer(description="Item ID"),
    "name": fields.String(description="Item name", required=True),
})

@items_ns.route("")
class ItemList(Resource):
    @items_ns.marshal_list_with(item_model)
    def get(self):
        """List all items"""
        return [{"id": 1, "name": "Example"}]
```

2. Register in `backend/api/__init__.py`:
```python
from .items import items_ns
api.add_namespace(items_ns)
```

3. Visit `/api/docs` — the new namespace appears automatically in Swagger UI.

### 6.2 How to Add a New Jinja2 Page

1. Create `backend/templates/about.html`:
```html
{% extends "base.html" %}
{% block title %}About{% endblock %}
{% block content %}
<h1>About</h1>
<p>Page content here.</p>
{% endblock %}
```

2. Add route in `backend/routes/pages.py`:
```python
@pages_bp.route("/about")
def about():
    return render_template("about.html")
```

3. Optionally add a nav link in `backend/templates/base.html`.

---

## 7. Naming Conventions

| Item | Convention | Example |
|------|-----------|---------|
| Python modules | snake_case | `user_routes.py` |
| Python variables/functions | snake_case | `get_user_data()` |
| flask-restx namespaces | snake_case suffix `_ns` | `items_ns` |
| flask-restx models | PascalCase | `Item`, `HealthCheck` |
| flask-restx Resources | PascalCase | `ItemList(Resource)` |
| JavaScript variables/functions | camelCase | `getUserData()` |
| React components | PascalCase | `UserProfile.jsx` |
| Directories | kebab-case | `user-management/` |
| Bash scripts | kebab-case | `run-backend.sh` |
| Environment variables | UPPER_SNAKE_CASE | `BACKEND_PORT` |
| Frontend env vars | VITE_ prefix + UPPER_SNAKE_CASE | `VITE_API_BASE_URL` |
| Git commits | Conventional commits | `feat:`, `fix:`, `infra:`, `docs:` |

---

## 8. Technology Stack (Fixed)

| Layer | Technology | Version Constraint |
|-------|-----------|-------------------|
| Backend framework | Flask | latest stable |
| Backend CORS | flask-cors | latest stable |
| **Backend API + Swagger** | **flask-restx** | **latest stable** |
| Production WSGI | Gunicorn + eventlet | latest stable |
| Frontend framework | React | ^19.x |
| Frontend build tool | Vite | ^7.x |
| Frontend routing | react-router-dom | ^7.x |
| Web server | Apache (reverse proxy) | system version |
| SSL | Let's Encrypt via certbot | system version |
| Process manager | systemd | system version |
| Configuration management | Ansible | system version |
| Version control | Git (3-branch model) | system version |

**Do not substitute** these technologies unless explicitly instructed.

---

## 9. What NOT to Change When Cloning

These files and patterns must remain intact in every site cloned from the template:

1. **`script/settings.sh`** — the auto-detector logic (environment detection from PWD)
2. **`script/manage.sh`** — the `--frontend`/`--backend`/`--gunicorn` dispatcher interface
3. **`script/generate-env.sh`** — the .env generation pipeline
4. **`script/run-backend.sh`**, **`run-frontend.sh`**, **`run-gunicorn.sh`** — launcher scripts
5. **`backend/config.py`** — the environment variable reading pattern (extend, don't replace)
6. **`backend/app.py`** — the `create_app()` factory pattern and `app = create_app()` module-level variable
7. **`backend/api/__init__.py`** — the Blueprint-based Api pattern (Api on Blueprint, not on app)
8. **`backend/api/__init__.py`** — the JSON/HTML error isolation in `handle_404`
9. **`GET /api/health`** — the health-check endpoint (keep it, add namespaces alongside it)
10. **`.gitignore`** — the exclusion of generated files
11. **The `VITE_` prefix convention** for frontend environment variables
12. **Localhost binding** (`127.0.0.1`) for backend servers
13. **The three-branch git structure** (`main`, `staging`, `dev`)

---

## 10. What to Customize When Cloning

These are the expected modification points for each new site:

| File | What to Change |
|------|---------------|
| `backend/api/*.py` | Add new flask-restx namespaces (one file per resource) |
| `backend/api/__init__.py` | Register new namespaces with `api.add_namespace()` |
| `backend/routes/pages.py` | Add new Jinja2 page routes |
| `backend/templates/*.html` | Add page templates (extend `base.html`) |
| `backend/templates/base.html` | Update nav links, site name, branding |
| `backend/static/css/app.css` | Override base styles with site-specific design |
| `backend/config.py` | Add new config variables (extend the Config class) |
| `backend/requirements.txt` | Add project-specific Python packages |
| `frontend/src/App.jsx` | Replace health-check demo with actual UI |
| `frontend/src/components/` | Add React components |
| `frontend/package.json` | Add project-specific NPM packages |
| `frontend/index.html` | Update `<title>` and meta tags |
| `script/settings.txt` | Add shared non-secret config specific to this site |
| `README.md` | Update with site-specific documentation |

---

## 11. Integration with site-management/ (Ansible)

*(Unchanged from v1)*

The platform-template does **not** stand alone. It depends on `site-management/` for:

| What Ansible Provides | Where It Goes |
|-----------------------|--------------|
| Port assignments | `script/settings.{dev,staging,prod}.sh` |
| Environment names | `script/settings.{dev,staging,prod}.sh` |
| Debug flags | `script/settings.{dev,staging,prod}.sh` |
| Apache vhost configs | `/etc/httpd/conf.d/NNN-domain.conf` |
| SSL certificates | `/etc/letsencrypt/live/NNN-domain/` |
| Systemd service files | `/etc/systemd/system/<site>.service` |
| Systemd env files | `/etc/systemd/system/<site>.env` |

**The app never generates its own infrastructure config.** Ansible is the single source of truth.

---

## 12. Backward Compatibility Contracts

These contracts are enforced by existing scripts and must never break:

| Contract | Dependent Script | Implementation |
|----------|-----------------|----------------|
| `python3 app.py` starts server | `run-backend.sh` line 22 | `if __name__ == "__main__"` block |
| `gunicorn app:app` is importable | `run-gunicorn.sh` line 24, systemd | `app = create_app()` at module level |
| `Config` class in `config.py` | `app.py` line 8 | `app.config.from_object("config.Config")` |
| `GET /api/health` returns JSON | Platform convention | `{"status":"ok","env":"..."}` |
| `/api/docs` serves Swagger UI | Developer workflow | `Api(api_bp, doc="/docs")` |

---

## 13. Quick Reference — Common Commands

```bash
# Start development (from site worktree)
./script/manage.sh --frontend        # Vite dev server
./script/manage.sh --backend         # Flask dev server

# Start production
./script/manage.sh --gunicorn        # Gunicorn with eventlet

# Regenerate .env files
./script/generate-env.sh

# Install backend dependencies
cd backend && pip install -r requirements.txt

# Install frontend dependencies
cd frontend && npm install

# Build frontend for production
cd frontend && npm run build

# Open Swagger UI (after backend is running)
# Browser: http://localhost:5001/api/docs

# Test health endpoint
curl http://localhost:5001/api/health
```

---

## 14. Related Documents

| Document | Location | Purpose |
|----------|----------|---------|
| Backend Architecture (deep dive) | `game-of-squares/PnT_Instructions/backend_architecture.md` | Blueprint pattern, how to add namespaces/pages, error isolation details |
| Platform Template Reference v1 | `game-of-squares/PnT_Instructions/platform_template_reference.md` | Previous version (superseded by this document) |

---

**Last Updated:** 2026-02-10
**Template Version:** 2.0
