"""Script executor with real-time SocketIO streaming."""

import os
import subprocess
import threading

from config import OUTPUT_DIR, VALIDATOR_SCRIPT, VALID_COMMANDS


class ScriptExecutor:
    """Runs validator.sh commands in a subprocess with live output streaming."""

    def __init__(self):
        self._lock = threading.Lock()
        self._running = False
        self._current_command = None
        self._process = None

    @property
    def is_running(self):
        return self._running

    @property
    def current_command(self):
        return self._current_command

    def run(self, command, url, socketio, options=None):
        """
        Execute a validator command asynchronously with live streaming.

        Args:
            command: One of the VALID_COMMANDS
            url: Target URL
            socketio: Flask-SocketIO instance for emitting events
            options: Optional list of extra args (e.g. ['--save', '--verbose'])
        """
        if command not in VALID_COMMANDS:
            socketio.emit("command_error", {"error": f"Invalid command: {command}"})
            return

        if not self._lock.acquire(blocking=False):
            socketio.emit("command_error", {
                "error": "Another command is already running. Please wait."
            })
            return

        self._running = True
        self._current_command = command

        def _execute():
            try:
                args = [VALIDATOR_SCRIPT, command, url]
                if options:
                    args.extend(options)

                socketio.emit("log_line", {
                    "line": f"[UI] Starting: ./validator.sh {command} {url}"
                })

                env = os.environ.copy()
                proc = subprocess.Popen(
                    args,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    cwd=os.path.dirname(VALIDATOR_SCRIPT),
                    env=env,
                )
                self._process = proc

                # Drain stdout in a background thread to prevent pipe deadlock.
                # Commands like 'html' can write >64KB to stdout, filling the
                # OS pipe buffer and blocking the subprocess if we only read
                # stderr in the foreground.
                stdout_chunks = []

                def _drain_stdout():
                    stdout_chunks.append(proc.stdout.read())

                stdout_thread = threading.Thread(target=_drain_stdout, daemon=True)
                stdout_thread.start()

                # Stream stderr (log lines) in real-time
                for line in proc.stderr:
                    stripped = line.rstrip("\n")
                    if stripped:
                        socketio.emit("log_line", {"line": stripped})

                stdout_thread.join()
                stdout_data = stdout_chunks[0] if stdout_chunks else ""
                proc.wait()

                if proc.returncode == 0:
                    # Find output files generated by this command
                    result_files = self._find_result_files(command)
                    socketio.emit("command_complete", {
                        "command": command,
                        "return_code": 0,
                        "stdout": stdout_data,
                        "result_files": result_files,
                    })
                    socketio.emit("log_line", {
                        "line": f"[UI] Command '{command}' completed successfully."
                    })
                else:
                    socketio.emit("command_error", {
                        "error": f"Command exited with code {proc.returncode}",
                        "return_code": proc.returncode,
                        "stdout": stdout_data,
                    })
                    socketio.emit("log_line", {
                        "line": f"[UI] Command '{command}' failed (exit code {proc.returncode})."
                    })

            except FileNotFoundError:
                socketio.emit("command_error", {
                    "error": f"Script not found: {VALIDATOR_SCRIPT}"
                })
            except Exception as e:
                socketio.emit("command_error", {
                    "error": f"Execution error: {str(e)}"
                })
            finally:
                self._running = False
                self._current_command = None
                self._process = None
                self._lock.release()

        thread = threading.Thread(target=_execute, daemon=True)
        thread.start()

    def _find_result_files(self, command):
        """Return list of output files relevant to the completed command."""
        files = []
        if not os.path.isdir(OUTPUT_DIR):
            return files

        for f in sorted(os.listdir(OUTPUT_DIR)):
            filepath = os.path.join(OUTPUT_DIR, f)
            if os.path.isfile(filepath):
                files.append({
                    "name": f,
                    "size": os.path.getsize(filepath),
                    "modified": os.path.getmtime(filepath),
                })

        # Sort by modification time descending (newest first)
        files.sort(key=lambda x: x["modified"], reverse=True)
        return files
